<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[不使用 + 、-求两个数的和 （含符号）]]></title>
    <url>%2F2020%2F06%2F19%2F%E4%B8%8D%E4%BD%BF%E7%94%A8%20%2B%20%E3%80%81-%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E5%92%8C%20%EF%BC%88%E5%90%AB%E7%AC%A6%E5%8F%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[不使用 + 、-求两个数的和 （含符号）首先想到用位运算符来处理 ^ 异或 可以理解为不进位的加法 如: 0010 ^ 0101 = 0111 0 + 0 = 0 | 1+1 = 0 | 1 + 0 = 1 &amp; 按位与 &lt;&lt; 按位左移 分析： 既然 ^ 异或可以得到不进位得值，那么再通过 &amp; 按位与取得需要进位的位， 再 &lt;&lt; 按位左移进位就可以取得进位的值 将 没进位的和 ^ 进位 接着再进行以上的操作，没进位的和 &amp; 进位 直到 &amp; 的值为0时就代表没有进位了， 就返回 没进位的和 ^ 进位 的值 eg: 9 + 7 = 1001 + 0111 s1 = 1001 ^ 0111 = 1110 | 1001 &amp; 0111 = 0001 | j1 = 0001 &lt;&lt; 1 = 0010 j2 = s1 &amp; j1 = 1110 &amp; 0010 = 0010 &lt;&lt; 1 = 0100 (还有进位，继续执行上述步骤) s2 = s1 ^ j1 = 1110 ^ 0010 = 1100 J3 = j2 &amp; s2 = 0100 &amp; 1100 = 0100 &lt;&lt; 1 = 1000 s3 = j2 ^ s2 = 0100 ^ 1100 = 1000 J4 = j3 &amp; s3 = 1000 &amp; 1000 = 1000 &lt;&lt; 1 = 10000 s4 = j3 ^ s3 = 1000 ^ 1000 = 0000 j5 = j4 &amp; s4 = 1 000 &amp; 0000 = 0 0000 s5 = j4 ^ s4 = 1 0000 ^ 0 0000 = 1 0000 = 16 j s 实现123456789101112let add = function(a,b) &#123; let sum = a ^ b; let carry = (a&amp;b) &lt;&lt; 1; if(a&amp;b) &#123; return add(sum, carry); &#125; else &#123; return sum; &#125;&#125;add(10, 6) // 16add(-2, 8) // 6 python 实现1234567891011#!/usr/bin/python3def add(a, b): if(b == 0): return a sum = a ^ b carry = (a &amp; b) &lt;&lt; 1 return add(sum, carry) nums = add(2,99) // 101]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点梳理 --part one]]></title>
    <url>%2F2020%2F06%2F10%2F%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%A2%B3%E7%90%86%20%20%20--part%20one%2F</url>
    <content type="text"><![CDATA[前端知识点梳理 –part one基础部分1. Html 语义化的好处 ? 使html的结构更清晰，更直观，更易于seo 2. 清除浮动的方法有哪些 ？ 定义一个空标签再浮动元素之后。 然后给其 clear: both 定义伪元素来清除浮动 使用overflow:auto（空标签元素清除浮动而不得不增加无意代码的弊端,,使用zoom:1用于兼容IE）。 3. img标签 alt 和 title的异同 alt 是当图片显示不出来时显示的文字。 title 是hover时显示的提示文字。 (描述性文字， 一直都有) 总结： alt是当正常图片显示不出来时的替代内容。title是一直存在的描述性内容。 4. 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些? 行内元素: i、strong、b、bm、a、span、input、select、img 块级元素: div、h(x)、p、ul、ol、li 空元素 br 5. html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 新增的元素 语义化元素: article、section、header、nav、footer 音视频元素：video、audio 画布元素： canvas 表单控件： time、email、date、calendar…… 缓存 local storage、session storage 新技术： webworker(为 JavaScript 创造多线程环境)、geolacation、websocket 移除的元素 frame、frameset，noframes 纯表现的元素： basefont，big，center，font, s，strike，tt，u 如何支持新的标签 直接使用成熟的框架、使用最多的是html5shim框架 如何区分是html5 docType/新增的元素 6. 介绍一下CSS的盒子模型？ IE盒模型 ｜ 标准盒模型 IE盒模型的计算方式是 border + padding + content = 宽 ｜ 高 标准盒模型计算方式是 content = 宽 ｜ 高 7. css3新增属性? Border- 边框(shadow、img、radius) Background-背景 (image、size、origin(相对不同盒模型)、clip(相对不同盒模型裁剪)) — (border-box、content-box、padding-box) gradients 渐变。 线性渐变 – Linear Gradients 。 径向渐变 – Radial Gradients 文字效果 (text-shadow: 文字阴影、box-shadow: 盒子阴影 、text-overflow: 文字溢出处理、 word-wrap: 文字换行、 word-break： 拆分换行,非中日韩文本) 字体: @font-face 2D、3D转换 . 2D : translate(移动)、 rotate(旋转)、 scale(缩放)、 matrix(包含旋转，缩放，移动（平移）和倾斜功能。 3D: 2D属性的3D体现 过渡: transition 动画 @keyframes 规则 。 animation ： 使创建的规则生效 多列布局 column-xxx 弹性布局 flex 媒体查询 @media xxx and (max-with: xxxpx) {}]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>summary</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二进制流转图片]]></title>
    <url>%2F2020%2F04%2F07%2Fblob2pic%2F</url>
    <content type="text"><![CDATA[二进制流(ArrayBuffer)转为图片 首先通过ajax或者ws获取到传来的二进制流数据 responseType 需要设置为arraybuffer。 然后我们拿到所需的二进制数据， 通过console打印发现是一个ArrayBuffer，接着我们对其进行如下处理，转为base64: 1234567891011121314151617function arrayBufferToBase64(buffer) &#123; var binary = ''; var bytes = new Uint8Array(buffer); var len = bytes.byteLength; for (var i = 0; i &lt; len; i++) &#123; binary += String.fromCharCode(bytes[i]); &#125; return window.btoa(binary);&#125; 显示图片。 接着我们把收到的二进制数据通过上面的函数转为url: 1let url= arrayBufferToBase64(response); ​ 然后将生成的url放到img标签的src属性中： 1document.getElementById('img').src='data:image/jpeg;base64,'+url; ​ 大功告成～]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>blob</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nuxt i18n国际化]]></title>
    <url>%2F2019%2F03%2F31%2FNuxt.js%20%20i18n%E5%9B%BD%E9%99%85%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Nuxt.js集成国际化前言​ 公司官网需求要加上国际化， 之前官网使用的是vue的 nuxt框架，然后generate生成的静态页面，看了一下，nuxt官方有集成i18n的示例就跟着弄了一下，期间也踩了一些坑。 准备工作安装​ npm install vue-i18n –save 在nuxt.config.js 中配置​ 12345plugins: ['~/plugins/i18n.js'],router: &#123; middleware: ['i18n']&#125; 在plugins文件夹下新建i18n.js​ 12345678910111213141516171819202122232425import Vue from 'vue'import VueI18n from 'vue-i18n'Vue.use(VueI18n)export default (&#123; app, store &#125;) =&gt; &#123; // Set i18n instance on app // This way we can use it in middleware and pages asyncData/fetch app.i18n = new VueI18n(&#123; locale: store.state.locale, fallbackLocale: 'cn', messages: &#123; en: require('~/locales/en.json'), cn: require('~/locales/cn.json') &#125; &#125;) app.i18n.path = link =&gt; &#123; if (app.i18n.locale === app.i18n.fallbackLocale) &#123; return `/$&#123;link&#125;` &#125; return `/$&#123;app.i18n.locale&#125;/$&#123;link&#125;` &#125;&#125; 在middleware文件夹下新建 i18n.js​ 12345678910111213141516171819202122export default function (&#123; isHMR, app, store, route, params, error, redirect &#125;) &#123; const defaultLocale = app.i18n.fallbackLocale // If middleware is called from hot module replacement, ignore it if (isHMR) return // Get locale from params // const locale = params.lang || defaultLocale const locale = params.lang || defaultLocale if (store.state.locales.indexOf(locale) === -1) &#123; return error(&#123; message: 'This page could not be found.', statusCode: 404 &#125;) &#125; // Set locale store.commit('SET_LANG', locale) app.i18n.locale = store.state.locale // If route is /&lt;defaultLocale&gt;/... -&gt; redirect to /... if (locale === defaultLocale &amp;&amp; route.fullPath.indexOf('/' + defaultLocale) === 0) &#123; const toReplace = '^/' + defaultLocale + (route.fullPath.indexOf('/' + defaultLocale + '/') === 0 ? '/' : '') const re = new RegExp(toReplace) return redirect( route.fullPath.replace(re, '/') ) &#125;&#125; 创建本地语言库​ 在根目录下新建文件夹locales， 然后在文件夹下添加你要翻译的语言的json文件 。 在store文件夹下新建index.js​ 123456789101112export const state = () =&gt; (&#123; locales: ['en', 'cn'], locale: 'cn'&#125;)export const mutations = &#123; SET_LANG(state, locale) &#123; if (state.locales.indexOf(locale) !== -1) &#123; state.locale = locale &#125; &#125;&#125; 踩坑……​ 好了，照着官方把该加的都加了，这下就能实现国际化的切换了吧。 然后参考了几篇文章， 通过 this.$i18n.locale = Langname 或是 this.$store.commit(‘SET_LANG’, lang) 切换语言。 结果要不就是404， 要不就是一个页面切换了，然后换个页面，也就是切换了路由又变回原来的语言了。。。 ​ 结果找了好久发现是路由的问题，主要是middleware中的这一段代码: 1234567const locale = params.lang || defaultLocale if (store.state.locales.indexOf(locale) === -1) &#123; return error(&#123; message: 'This page could not be found.', statusCode: 404 &#125;) &#125; // Set locale store.commit('SET_LANG', locale) app.i18n.locale = store.state.locale 每次我们切换页面的时候都会调用这个中间件，然后会去判断路由中的params 如果lang参数有值就将语言设置为对应的值。 ​ 比如我的地址是 “http://localhost/zn/&quot; 那么中间件就会将当前的lang设置为zn 如果就是”http://localhost/&quot; 就会设置为默认的值. ​ 所以之前我们手动设置了store中的值，切换了路由就会变回原样是因为每次中间件都会把locale设置成默认值(因为我们路由中没有带参数)。 ​ 可是当我们路由带上参数后切出现找不到页面的情况，这是因为当前路径下，比如 “http://localhost/zn/&quot; 找不到我们的页面。 这是我们就要用到nuxt提供给我们的一个 动态路由的功能。 ​ 动态路由根据官方可如下配置，因为nuxt是根据page下目录生成路由，可如下组织目录: _lang 就是动态路由下的参数项，这样不管是带不带参数都能找到页面了。]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>i18n</tag>
        <tag>nuxt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css多行文本省略号]]></title>
    <url>%2F2019%2F03%2F21%2Fcss%E5%A4%9A%E8%A1%8C%E6%96%87%E6%9C%AC%E7%9C%81%E7%95%A5%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[CSS多行文本设置省略号单行文本省略号 如果要设置单行文本超出容器末尾显示省略号是非常简单的，通过: 12overflow: hidden;text-overflow: ellipsis; 即可实现单行文本的省略号。 多行文本的省略号​ 下面就是本文主要讨论的点了，如何实现多行文本超出区域显示省略号，或者说可以设置最多显示几行。 ​ 实现的方式有多种，可以用css，也可以用js。 其中css也有多种方法, 但一些方法或多或少都有点hack的味道，下面我们介绍一种浏览器原生的多行文本显示的方法。 在包含文本的标签中添加如下css样式: 1234567p &#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 4;&#125; Tips: 1. 只有中文内容在到达最大宽度时才会自动换行 如果要英文支持的话需要添加 word-break: break-all 文本才会换行。 经测试 此css样式在chrome、safari浏览器上能正常生效，但在Firefox上好像并不起效果。 踩坑​ 单独尝试添加上面的样式可以实现多行省略号，但我在Vue以及nuxt框架下开发，几经尝试都不起效果，一直认为是不是浏览器不支持这个样式。结果倒腾许久才发现是 autoprefixer这个插件干的”好事”。 在原来的css中我们添加了-webkit-box-orient: vertical 这个样式。 但是经过 autoprefixer 处理之后，元素中竟然没有了！！ 好吧。。。 手动加上之后就可以实现多行文本省略号的效果了。 ​ 那怎么解决 autoprefixer去掉 -webkit-box-orient: vertical 这个样式的问题呢？ 很简单，在该样式样多加一条注释 /*! autoprefixer: off */ 。 ​ 哦了，这下我们就能愉快的使用多行文本设置省略号了～]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>css技巧</tag>
      </tags>
  </entry>
</search>
